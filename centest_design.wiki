=centest系统结构设计=
{{{
CenTest设计
2012-05-29 08:26:57

逆序数的计算
对于近似升序排列的序列中,计算其逆序数.

数据包统计
1,序列,存储其最大值和最小值,计算就可以得到理论上序列元素的个数.
与实际个数做差,就知道丢包数,进而计算丢包率.
2,逆序数的计算
正序的逆序数为0,逆序的逆序数为N-1+...+1+0=N(N-1)/2
逆序指数为
     序列逆序数/全逆序逆序数
逆序数的计算可以使用归并排序算法的变形,但是不很适合为本问题.
本问题最好是实时迭代更新的.而且序列也是有自身特点的,就是基本上是正序的.
还有树状数组的解法:http://blog.csdn.net/cattycat/article/details/5640838
关于树状数组(二分索引树)的介绍文章:http://duanple.blog.163.com/blog/static/7097176720081131113145832/
使用游程编码,可以减少存储的数据量
求逆序的思路：
可以把数一个个插入到树状数组中， 每插入一个数， 统计比他小的数的个数，对应的逆序为 i- getsum( data[i] )，其中 i 为当前已经插入的数的个数， getsum( data[i] ）为比 data[i] 小的数的个数，i- getsum( data[i] ) 即比 data[i] 大的个数， 即逆序的个数。最后需要把所有逆序数求和，就是在插入的过程中边插入边求和。
就是插入(新得到的数字),然后利用树状数组的特性,计算之前比它大的数的个数,然后累加起来,(说白了,就是逆序数的定义)
测试运行过程,
1,中心根据配置发送各个节点,开始测试的请求;
2,各个节点发起SM到Xing的会话,同时运行信息收集程序.
3,信息收集程序收集信息,同时每隔固定时间长度,向中心节点汇报自己的丢包率以及乱序率.
4,中心节点可以随时终止整个测试过程.
5,中心节点必须还可以配置,支持具体对每个节点的任务具体分配.
配置文件支持
节点组(组内节点配置相同,仅仅IP地址不同)
节点组列表配置信息(点播文件,点播类型,点播个数,点播时长等等信息,被点播的概率)
节点组内的IP地址
节点的反馈时间间隔
[group]
[playlist]
E_F***.MP4      vod      100      80     //播放文件E_F***MP4,以vod形式点播,点播长度为100,80%概率点播到
MCP***.mov     tvs       100     20  
[nodelist]
10.0.167.100     username password 100                         //节点IP地址如下,发起100个连接
10.0.167.101     username password 200
10.0.167.102     username password 100
以上为一个配置样例
远程运行程序的方法
1,登陆到远程机器上,使用telnet/ssh,然后运行特定的程序
2,IPC$(因特网进程连接)以及ADMIN$命名管道方法
3,AT   \\IP\目录\EXE 对方的计划任务功能要被打开
4,WOLLF.exe

4．定期自动运行程序 
Linux有一个称为crond的守护程序，主要功能是周期性地检查 /var/spool/cron目录下的一组命令文件的内容，并在设定的时间执行这些文件中的命令。用户可以通过crontab 命令来建立、修改、删除这些命令文件。 
例如，建立文件crondFile，内容为“00 9 23 Jan ＊ HappyBirthday”，运行“crontab cronFile”命令后，每当元月23日上午9:00系统自动执行“HappyBirthday”的程序（“＊”表示不管当天是星期几）

5,远程过程调用的C方法
http://zhoulifa.bokee.com/6128714.html
6,LKM可装载内核模块的方法

设计方案
1,中心节点负责读取配置,发起点播,收集测试信息,测试信息汇总,终止测试.
2,点播节点,收取点播信息,根据点播信息发起点播程序
2.1点播程序,负责点播.
3,数据收集节点,负责收取网络数据包,检测评价丢包与乱序情况,将信息汇总到中心节点

Cygwin下面情况不好用啊,特别是这样涉及到调用模式,这样跨平台的东西.
gcc -c -fPIC *.c
gcc -shared *.o -o lib**.so

2012-06-06 21:46:49
ctypes支持c库,已经将client_sm部分编译为动态链接库

2012-06-10 15:13:06
需要python支持C结构中的结构体,这个暂时还没有办法搞定,暂时在尝试过程中.
如果没有这个功能的话,就需要进行自己编写发送模块,这样带来不必要的麻烦.
今天就无法完成第2个部分的功能.

2012-06-10 17:26:45
cen重构完成

2012-06-11 20:05:02
添加配置文件注释功能

2012-06-11 21:30:37
加入事件机制,准备多个线程的点播

2012-06-12 17:30:54
事件机制无法提供参数,修改为使用同步队列,这样基于消费者和生产者模式,来进行同步.
发起点播正在完成中.

2012-06-12 22:30:27
完成ctype的调用功能
正在进行调用测试

2012-06-13 09:58:18
完成xing和client模块联合.

2012-06-13 14:03:53
完成ctype调用功能,现在完全可以播放了(使用python通过ctype结构调用一系列指令)

2012-06-13 20:18:19
可以跳过dispatcher的交互过程.

2012-06-13 21:37:00
conf信息从中心节点传递到测试节点

2012-06-13 23:12:16
多个点播完成
至此,可以说req模块完成了
(退出部分为暴力退出)

2012-06-14 09:52:44
添加温和的stop和run机制,这样就不会暴力退出了.

2012-06-14 10:36:39
3 最好在北京的代码中将下面被屏蔽的代码打开，作用是在发包前将待发送的数据保存到本地文件，这样便于我定位问题是在发包前、发包模块还是网络。
trunk/RtpModule/RtpSession.cpp，第683到685行。
678         if (-1 == sendto(theStreamInfo->m_SocketID, data->m_PacketData + 20, dataLen - 20, 0,
679                                 (sockaddr*)&(theStreamInfo->m_remoteAddr), sizeof(theStreamInfo->m_remoteAddr)))
680         {
681                 perror("sendto()");
682         }
683         FILE *fp = fopen("/root/out.ts", "a+");
684         fwrite(data->m_PacketData + 20, sizeof(char), dataLen - 20, fp);
685         fclose(fp);
686         delete[] data->m_PacketData;
687         data->m_PacketData = NULL;
然后重新测试下，将本地保存的文件out.ts和IPQAM上抓包结果进行对比。
增加RTP的信息输出

2012-06-14 14:45:58
rec节点内容基本完成
目前关键是怎样将recv进程的数据,传送给定时器,让定时器汇总消息发送给中心管理员


2012-06-14 16:25:30
基本配合完成
下一步工作:
1,统计信息,当seq再次从0开始计数的时候出现问题.
2,发送统计信息到中心节点
3,中心节点的界面设计

2012-06-14 19:21:11
统计信息可以发送到中心节点了,

2012-06-14 19:37:22
自动登陆和执行的方案
1,利用ssh的密钥登陆方式
2,使用一个脚本,scp之后再运行程序,之后自己退出.

颜色方案
白(正常<1%的丢包率)
绿色(1%~3%的丢包率)
黄色(3%~7%的丢包)
红色(>7%的丢包)

2012-06-21 11:19:15
需要加入延迟和抖动的统计信息

2012-07-09 15:21:33
重构开始部分
完成各种server类型的重构.
参考了Erlang的设计思想

测试工具要求
指定在一段时间内发送多少个连接数,指定/随机影片
}}}
