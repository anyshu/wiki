= lisp学习手册 =
----

[[lisp_interpretator|lisp解释器]]
[[clojure|学习clojure]]
----
== 标点符号 ==
# 单引号
'a		;(quote a)的缩写

quote表示的是避免对输入参数进行求值,保持原有样子.


# @符号
将反引用模板所生成的表达式列表嵌入到结果表达式中.

(defmacro check (&body forms)
	`(progn
		,@(loop for f in forms collect `(report-result ,f ',f))))

progn表示的是多表达式归一的用处
# `反引号
反引号也可以用于阻止求值,类似与单引号.区别在于反引号的表达式中,可以用逗号让子表达式求值.

`(1 2 (+ 1 2)) --> (1 2 (+ 1 2))
`(1 2 ,(+ 1 2))--> (1 2 3)

# ,逗号
见关于反引号的说明

# &符号
&body,表示参数的类型/名称

一个分析的例子
{{{
; 定义宏，不是函数，宏本质是一种代码的替换
(defmacro as (tag content)
  `(format t "<~(~A~)>~A</~(~A~)>"
           ,tag ,content ',tag))
; 这里定义的时候使用了很多特殊符号，这里一一解释下。
; 第一个反引号，表示阻止求值，
;       但是内部中以逗号开始的部分是可以进行求值的。
; 单引号，用于quote，避免求值
; 逗号，用于反引号组合使用
;
; 就此解释：逗号content，表示后面的内容会进行计算之后进行替换
; ',tag表示不会进行求值直接计算
; 'tag则直接只输出“tag”
; ,tag则会尝试对tag进行计算,这种方式如果tag是一个字符串的话，是可以的
; 但是当tag不是字符串标识的会就会尝试求值center，进而出现center没有对应值的错误
}}}

== 讨论 ==
这里有个关于lisp很有意思的讨论.

大体而言,lisp强大的表达能力,反而决定了其很难从次级效应(次级程序员从高级程序学习)获得好处.

[[http://www.soimort.org/posts/124/]]

=== 同象性 ===
也就是"代码既数据".这是lisp的重要特性.

代码本身就直接是AST(抽象语法树),这样可以直接利用宏,和构建DSL.给语言更为强大的表现力.

对于其他语言而言,就必须要采用类似与"代码生成,文本宏和预处理,编译器插件"等方式来完成类似的功能.
