= p2p =
mtime: 2013-07-11 11:30:03 
----

== torrent文件格式 ==
文本文件,包含tracker和文件信息.
# tracker信息用于确定tracker服务器的地址,以及设置.
# 文件信息,对目标文件进行计算得到的.将文件虚拟为大小相等的块,块大小为2k的整数次方.并把块的索引信息和hash值写入种子文件.

一般具体包含下面的内容:
# announce tracker的URL
# info 字典,指向具体的文件信息
    # name 建议保存的文件和目录名称
    # piece length 每个块的字节数,通常为256kB
    # pieces 每个块的SHA-1的hash值.
    # length 文件的大小(字节为单位)
    # files 字典列表,(每个字典对应为一个文件)
        # path 一个对应子目录名的字符串列表,最后一项为实际的文件名
        # length 文件大小(字节)

torrent文件中的内容根据bencode进行编码.

=== bencode规则 ===
这种方法,显然比纯二进制编码效率低,但是结构简单,不受字节存储顺序影响,灵活.

# 字符串
    - [长度]:[内容]
    - (长度,但是不可以为负数.内容直接为字符串内容.注意不能处理ASCII以外字符,非标准方式转化为UTF-8,之后进行编码
    - 4:spam
# 整数
    - 42 -> i42e
    - 0  -> i0e
    - -42 -> i-42e
# 线性表
    使用l和e括住.
# 字典
    使用d和e括住.字典中的键和值必须紧跟在一起,并且所有键为字符串类型,而且按照字典顺序排列.

表和字典可以包含其他元素.

bencode的解码方法利用python开发了解码模块,代码在test.g/py目录下.

== DHT ==
分布式hash表

将一个Key的集合分散到所有分布式系统中的节点,并且可以有效的将信息传送到唯一一个拥有查询者提供的key的节点上.???

是构建分布式更为复杂系统的基础.

中心查找式,泛洪查找.

之后有基于键的传送/路由方法.将每个文件与一个键对应,拥有相似键的文件被相似的节点构成的集合所保管.查询信息则根据提供的键,传送到该集合,而不需要经过所有的节点.但这种方法无法保证一定可以返回查找结果(如果该键对应的机器全部不在线的话)

缺点:只可以根据键进行精确搜索,无法提供部分关键词进行模糊搜索(但是可以在上层来做,只是不可以直接来做).

具体有4种DHT技术:
# CAN
# chord
# pastry
# taperstry

特性:
- 离散性(或者分布式,无任何中央式的协调机制)
- 伸缩性(键值关系,适应节点数据一直向上增加)
- 容错性(节点加入,离开,停止工作,系统仍然保持一定的可靠性)

关键技术:任何节点只需要与系统中的部分节点沟通.一般,系统有n个节点,则只有log(n)个节点是必须的.成员改变,只需要部分调整.

=== 结构 ===
- 键空间.
- 键空间分区
- 延展网络,则连接这些节点,并且能够借由在关键值空间中的任一值查找到该值的节点.

# 稳定散列,也就是保持值的距离信息到键空间中.

=== 延展网络 ===
每个节点保持一些到其他节点的链接,将链接总和起来就会形成延展网络.这些链接构成网络拓扑.

- 最大节点度O(1),转送长度O(logN)
- 最大节点度O(logN),转送长度O(logN/loglogN)
- 最大节点度O(logN),转送长度为O(logN)
- 最大节点度O(sqrt(N)),转送程度为O(1)
其中第3个最为常见,虽然不是最佳选择,但是可以弹性选择邻近节点.可以选择延迟较低的邻近节点.

== kademlia ==
一种DHT网络.

利用了异或距离,每次搜索迭代,距离目标减少1bit,从而实现logN的查找长度.

TODO:
进一步内容,参考维基百科.

