= 松本行弘的程序世界 =
mtime: 2012-11-15 19:05:02 
----
== ch4 设计模式 ==
库,软件复用的主要层次.

模式

日常编程中总结出来的习惯性写法.

设计模式的价值和意义.

# 明确了模式的效果和适用状况.
# 明确了模式的存在和如何去分类,提取模式.

对于动态语言/脚本与静态语言相比,会发现尽管事先类似的设计模式,对于代码的复杂度也是差别很大的.

=== ruby中的设计模式 ===
# Singleton模式
单例模式
# Proxy模式
代理模式.

也就是当程序中的某个部分过于复杂,适用Proxy来封装其操作或者行为,或者称之为委托 delegate .

这基本是一个转移的过程.

# 迭代器模式 Iterator
对于 C++ STL 比较熟悉的都会对此认识比较深入.

	# 外部迭代器:

Iterator 类,可以通过 begin(),end(),++,操作,从而完成了一个迭代的过程.

外部迭代器必须要访问目标类,因此就需要迭代器与目标类作为 friend 友元类才可以.

	# 内部迭代器:

就像 ruby,python 的方式,就是通过 Enumerate 的方式.

这种方式,就是通过 Enumerate 的方式,生成依次访问的序列,从而在序列上依次操作,达到迭代的目的.

这种方法的缺陷是,不能同时进行多个循环操作,而且不可以在迭代过程动态的修改目标类.

# 原型模式 prototype
这实际上可以上升为一种编程范式.

但是在动态语言中才可以方便的普遍使用.

原型模式,实际上是复制原有的对象,并且可以动态的对此添加方法,从而使得原型得以不断衍生.

# Template Method 模式
这是可以作为一个编程范式.

也就是在父类中定义类的方法框架,然后再子类中具体化实现各种具体内容.

这种方法的好处,是得以抽象出共同的部分,从而有共同的接口.

# 观察者模式 Observer
这种方法用于解耦合.也就是将关系紧密的部分,如何不让它们的关系纠缠在一起.

这种使用观察者来统一接收观察对象的注册,然后由观察者接收被观察对象的状态改变,观察者来通知注册对象发生了改变.

使用这种方法解决了耦合的问题.

 被观察对象						观察者	<---注册	观察对象
 
 被观察对象	--通知状态--->		观察者				观察对象
 
 被观察对象						观察者	->>通知		观察对象
 
= 开放封闭原则 =
对模块扩展必须开放 Open

对修改必须封闭 Close

DONE.(电子书)
