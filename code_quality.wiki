=code_quality=
2012-08-28 09 41 00

{{{
tips:
   scanf
   可以检查scanf结果的参数,返回成功的参数.这样可以避免输入上出现的各种入侵式的恶意输入.
   lint/FindBugs
   代码静态检查工具
   graphViz
   图形描述语言
   write系统调用,must check return value of WRITE sys call.because it may be interuppted by othter system call.
      example:
      static ssize_t atomic_write(int fd,char *buf,int count)
      {
         ssize_t got,need = count;
         while((got=write(fd,buf,need))>0 && (need-=got)>0)
            buf+=got;
         return (got<0? got:count-need);
      }
   处理多路分支
   1,switch+default
   2,将代码与数据联系起来,通过添加注册表,注册分支与函数的映射关系.而在原本多路分支的地方改用分发式的方法.
}}}

----

==时间性能==
时间,是大自然用来防止所有事情同时发生的手段.

衡量时间性能的参数:
- 延迟时间
- 吞吐率
- 处理器时间要求

	CPU的工作而不是等待的时间.这个时间CPU可以用于处理其他作业,而不必在空闲状态.
- 实时响应
	
	如果没有实时响应,这是带来质量下降,则为软实时系统.如果没有实时响应,将造成系统运行错误,则为硬实时系统.
- 时间变动性
	
	也就是比较一致的时间响应,而不会发生剧烈的变化.
	
一般有一个平衡的问题,可以通过将任务调整为批处理,这样回提高吞吐率,并且降低对CPU的时间要求.但是,这样会造成时间延迟增大,因为任务不是立刻处理的,而不是积累为一批处理.同时这样也会造成时间变动性变大.不再有非常稳定的处理时间.

类似的策略散见在各处,例如tcmpdump中网络数据的缓冲,标准输出流的块缓冲.

一般偏向与牺牲带宽,而保持较小的时间延迟.因为带宽等一般回随着硬件水平而上升,而时间性能的硬件红利往往没有那么明显.

而使用 *合适* 的算法才是关键.合适意味着不会偏颇与某一方.取得合适的平衡

- 复杂度与性能

	一般越高效的算法,越复杂,但是出现错误的可能性较大,因此应该取得合适的平衡,不要一味追求高性能.
- 优化与特定平台
- 优化与特定协议或者文件格式

	这个可以举个例子就是xmlrpclib,这个毫无疑问是可移植性最高的,但是性能就很差.而如果使用rfoo,则速度就快很多,但是这样就只可以在python环境下面使用.无法与其他语言进行交流.

M.A.Jackson:
# 优化:!!不要优化!!
# 优化第二原则:只为专家准备,还是不要优化!!

===受限于IO的任务===
{{{
一般距离CPU越远的地方,则速率越慢.
同时考虑程序的局部性原理.
需要各种本地化的技术,主要有3个方面
	缓存
	预取
	和XX??
}}}
===受限于内核的程序===
===受限于CPU的的程序===
剖析器profiler
有两种方法:定时采样,这种方法高效,而且对原始程序影响较小,缺点是精度不够,而且可能有错误.2,在每个函数都有调用之前的处理与之后的处理,这样就就回记录每个函数的运行情况.JVM和微软的CLR都是运用了这种技术,但是缺点是对原始程序影响很大,而且执行速度会很慢(matlab的profile就是这样的).

而最新的CPU一般都提供了基于硬件的时间性能计数器,这样专用的分析工具,如oprofile,就可以对其采样.获得信息.

通常,(第二种),受限需要将加特殊编译标签的程序,运行一次.第二步,对上一步的结果合并,分析.类似与gprof就是这样.

介绍gprof与ltrace用法,参考[[c_cpp_programming_tool]]

在嵌入式环境(类似于Hili平台),则可能系统模块较少,可能不提供上面的工具.这个时候可以通过硬件监控IO线的方法.

=== 算法复杂性 ===
算法复杂度:略

几乎所有算法在处理50个以下元素,都是可以容忍的.(但是对于组合增长的肯定是不行的)

查表法,可以有效降低复杂度.(但是仅仅是对于特定的有限的对象集合,上面的计算结果可以通过保存起来到表中,如果不满足此特性,则无意义;也可以通过每次新的计算都会计算一次,然后存到表中,之后就可以通过索引表得到结果.)

C/C++固有函数,可能就地编译,因此较快,例如strcmp,memcpy.

=== 操作系统交互 ===
mtime: 2012-10-18 16:06:12

unix与windows中都有独立的程序维护系统日志,该程序从系统种的各个进程接收日志记录信息,使用适当的格式依序加上时间戳信息到系统日志中.

IPC,显然这样时间性能将大大降低.
{{{
	平衡木,这里再一次体现出这个思想.
}}}

