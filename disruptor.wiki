= disruptor =
%toc

disruptor是一个线程交换数据的框架.应用了CAS的无锁队列.ref:[[struct]]

本文ref:[[http://coolshell.cn/articles/9169.html]]

特点:
# 没有锁,使用CAS
# 访问者都有记录自己序号的实现方式,允许多个生产者和多个消费者共享相同的数据结构
# 每个对方都可以跟踪序列号,加上cache line padding,则没有伪共享和非预期的竞争.

== 伪共享 ==
数据缓存以行的形式组成.(现在一般为64字节).

数据缓存的这种形式,加快了内存紧凑的数据结构的运行(例如数组).对于内存不够紧凑的(如链表),则没有那么友好.

但是对于逻辑上非紧凑(也就是不希望被缓存相互影响的)的数据,那么最好在内存的物理位置上,也将其分开比较好.

例如:两个相邻的数据,都是经常被更新的数据(而且是多CPU多线程的场景下).

那么,这二者会同时命中或者失效.这样就不得不以略2倍的频率,进行数据的更新,而更新缓存是非常消耗时间的.

甚至,如果两个线程同时对其缓存行进行写入,则还会造成写冲突(尽管二者写入的是不同的变量,但是是同一个缓存行中的变量).这个是缓存行的写竞争问题,在SMP系统中经常出现.

这种现象为 _伪共享_ .(也就是错误的共享方式).

`关于缓存,可以参考CSapp一书`

== 缓存行填充 ==
也就是填充一个额外的无用数据,来保证内存位置中,伪共享的数据不再共享同一个缓存行.

这就是cache line padding.

进行缓存行填充,需要对系统以及虚拟机的内存使用方式,有很清楚的了解.

== Hotspot JVM 内存布局 ==
对象头
* 24bit hash,和8bit 标志位(锁状态等信息)
* 对象所属类的引用
* 对于数据对象,数据长度.

对象字段按照字节大小进行重排.
# doubles(8)    longs(8)
# ints(4)       floats(4)
# shorts(2)     chars(2)
# booleans(1)   bytes(1)
# references(4/8)
# 子类字段.

== 内存屏障 ==
一个CPU指令.

* 确保一些特定操作的执行顺序
* 影响一些数据的可见性.
* 强制更新一次不同CPU的缓存.

这个是对于CPU乱序执行的一个防护措施.

在Java中,volatile描述的数据,在其写操作之后,将插入一个写屏障指令,在读操作前,加读屏障指令.来更新缓存和数据.

这样就可以达到在不同CPU,不同线程之间更新数据的目的.

同样的,相对于锁,它的开销没有那么大.但是需要打破CPU乱序执行,强制更新缓存,这些都是非常消耗时间的.

因此,应该尽量对数据进行批量操作,从而减少volatile数据的访问次数.

= ringbuffer =
这部分,参考[[struct]]
