=shell脚本专家指南=
mtime:2012-09-26 09:48:42 

==1,错误检测==
- 1.1 跟踪选项
	- `set -x`
		加跟踪输出标志(加中间结果,参数输出)
			
			脚本错误,使用*`*符号(反引号)表示执行脚本内容
	- `set -v`
		加详细输出标志(加命令输出)
	- set +xv
		关闭对应选项
- 1.2 简单输出
	上面的方法,在复杂脚本中就会出现大量的输出,需要的信息反而容易淹没在输出中,很难察觉.因此也可以使用特定的echo,print来完成具体脚本内容的输出.

	对于临时输出,可以在脚本编写的时候特意不按照标准来进行缩进,这样就会在删除的时候很明显的看到这一点.
- 1.3 使用debug标志
	使用debug=1来标志debug的等级

	使用`test $debug -gt 0 && echo "Debug is on"`来实际输出.或者`test $debug -eq 0 ...`

	这样就需要在开始处修改debug等级,就可以自动调节输出了.
	
- 1.4 函数简化
	`$?`shell内部变量,前一个命令的执行结果的返回值.

	{{{
		alert(){
		# usage: alter <$?> <obj>
		if [ "$1" -ne 0]
		then
			echo "warning: $2 failed" > &2
			exit $1
		else
			echo "INFO: $2 successed" > &2
		fi
	}}}

	{{{
		cat $LOG | mail -s "$FROM attempting to get $FILE" $TO
		alter $? "Mail of $LOG to $TO"
	}}}

- 1.5 单步执行
	- 就是单步.

==标准函数库==
- 2.1 库文件
	sheba行`!/bin/echo Warning: this lib should be sourced!`,保证库被引用,而不是直接执行
	
	或者直接将其设置为不可执行状态
- 2.2  有用的函数
	- ...
- 2.3 使用库
	- `source lib_name`
	- `. lib_name`(在ksh,bash中)
	在大量机器组成的网络系统中工作,保持一致性,最佳选择是库存储在中心NFS服务上,其次是在某个地方编辑,rsync将改变的内容到其他机器上.最差的方法是手动复制到每台机器上.

	如果工作环境是异构的,标准库是处理差异,保持可移植性的好方法.

==日期时间操作==
- 3.1 天数计算日期
	- 关于ntp,ntp不够好.
	这个不是很有必要,跳过.
- 3.2 评估当前时间
	- ..
==比较和测试==


==目录复制==
- 20.4 rsync
	rsync使用-a开关,则包含隐藏文件(.文件)目录复制,保持权限,所有权和修改时间.
	问题:

	必须注意最后的"/",如果没有,则表示将文件夹复制到目标文件夹,如果有,则表示将文件夹下的所有问题,复制到目标文件夹

	-e,通过特定的协议,比如最为常用的ssh

	-z,进行压缩处理
