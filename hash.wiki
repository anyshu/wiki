= hash =

mtime: 2013-07-12 13:59:25 
----
== 一致性hash ==
一致性hash的典型应用为分布式环境下,保证服务器节点的变化不需要造成大量的hash重定位.

这种算法,将hash地址的空间范围设为一个环状,从而不同节点负责不同的区域.而当节点加入与退出的时候,hash值将会迁移到逆时针的下一台机器上.(或者从上面分割出来)

TODO:
[[http://www.cnblogs.com/haippy/archive/2011/12/10/2282943.html]]

一致性hash的方式,还通过虚拟节点.在少量节点情况下,平衡各个节点的负责区域.
----
= 应用 =
hash应用是多样性的,有很多丰富的使用场景,对于不同场景下的要求的不完全相同的,针对不同的应用特性,设计不同类型的hash算法.

== 加密散列函数 ==
这里主要的特定是克服反向破解,发现碰撞字符串.也就是难伪造.对于这类hash函数,如果发现可以构建碰撞方法,就可以认为被破解了.md5,sha都属于加密散列函数.

加密散列函数可以应用于:
# 报文的防伪造检测.
# 文件分发中的防伪检测.

== 散列表/hash table ==
数据结构,用于存储/检索信息,可以提供O(1)复杂度的存储与检索.

这类hash方法,是要避免碰撞,尽可能的均匀分布.(和加密散列的需求还是不同的)
最关键的要求是均匀性.和低碰撞.

*heuristic函数*,所产生的冲突比随机散列函数少.
(启发式函数)

heuristic函数,例如了相似关键词的相似行,从而是的相似的关键词映射到连续指针上,且不冲突.

== 错误校正 ==
这类hash函数需要对于较小的错误变化,就可以作出反映.

有两个类型:循环冗余校验CRC,和里德-所罗们码

== 语音识别 ==

???

== Rabin-karp字符串搜索 ==
需要的搜索时间为O(n),建立在使用散列比较字符串的基础上的.

首先可以将 目标匹配字符串 转换为数字(比如,可以假设纯字母表字符串为26进制的数).

如果数值过大,才选用一个较大的质数,取模,作为其的值.

将待匹配字符串同样长度,也可以一样进行这样的转换.

显然如果二者相同,则字符串匹配.

如果发生不同,

则显然,待匹配字符串的下一位偏移,字符串可以通过

迭代新的待匹配字符串的同样程度的子串,对应的数值.

当然,如果进行了质数取模的操作,则即使二者值相等,也并非绝对相等,还需要进行一次朴素字符串匹配操作.

这种方法,的复杂度为O(n).是一个比较巧妙的方法.

== Bloom filter ==
布隆过滤器

用于判断一个数据是否存在的数据结构

特点:
* 耗时与数据个数无关
* 空间效率很好
误判率为1%情况下,每条数据需要9.6bit.(而且不需要存储原始数据,甚至不需要存储对应的hash值)
* 无法删除元素
* 不需要存储数据本身(适用于安全性需求)
* 偶尔会出错

错误都是假阳性,也就只会将不属于集合的误判为属于.但是不会出现假阴性(就是将属于集合的不会错判)

补救的办法,可以另建立误判的名单,可以对其进行检查.

算法:

k个散列函数,m比特的比特数组.

插入时候,将k个散列值作为索引,对应的散列值为索引的比特位设为1.

判断时,则计算该值的k个散列值,如果都为1,则说明该数据存在,否则说明不存在.

配置:

这里显然,如果k过大,则空间利用率降低,但是准确率提高.

应用:
可以应用与海量数据的存在性检查

== LSH ==
TODO:
