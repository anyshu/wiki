title: printf?
date: 2015-02-08 21:05:53
tags: [C, src]
---

printf这个函数，在C语言中是最基本的之一。可是有多少不了解的细节隐藏其中呢。
<!--more-->

## 可变参数列表
嗯，这个名词可能没有听说过。`man 3 printf`

    int printf(const char \*format, ...);

这里后面的。。。在编程时候怎么用呢？这就是可变参数列表，即可以加任意格式，任意个数的参数。

在函数的声明和实现的时候，都直接用三个点表示可变参数就可以了。这个三个点的参数只能放在最后一个。
但是这个任意参数列表要如何使用呢？
这就涉及到关于关于可变参数列表的几个宏了。

    // va_list 类型
    va_list ap;
    // 三个宏
    // 初始化ap，第二个参数为函数参数中从左到右的最后一个
    va_start(ap, [LAST PARAM]);
    // 取ap中的元素，并且按照强制转换为TYPE类型，然后返回
    // 下一次调用此宏，将会返回下一个参数。
    va_arg(ap, [TYPE]);
    // 结束,作为良好的工程习惯，这个宏必须调用。
    va_end(ap);

这个可变参数（Variable Argument，VA）是怎么实现的呢？C语言的函数调用时候，是从右向左压栈的。因此可变参数列表的区间，其实就是从栈的底部到正常参数之间的部分，这就是va\_start为什么需要[LAST PARAM]作为参数，因此以此向栈底移动，就到了可变参数列表的部分。基于这个原因,C语言的可变参数有下面的限制:

- 必须是最后一个参数
- 必须有一个其他参数(不能是唯一的参数)

然后按照从各种神奇渠道知道可变参数中某个参数的类型，然后强制转换就可以使用了。

这里的神奇渠道一般有2种方法。

- 假设所有参数都是一种类型，比如int。

不过这种方法不知道参数的个数，因此还需要一个正常参数来告知参数个数。

这种方法可以很容易写出一个接受任意参数个数的`int sum(int n, ...);`

- 加一个字符串作为参数，以字符串来中信息解释后面可变参数列表

字符串可以同时提供参数个数和参数类型的语义。

这种方式的最典型的例子，就是今天的主角：printf函数了。

    NOTE:
    va_arg(ap, [TYPE]);
    // 每次调用这个宏，会移动内部的指针，因此不是可重入的。
    // 因此需要保存每个参数的值。或者使用va_copy这个宏

    // 如果调用到参数列表结束，也就是到栈底。
    // 这个时候在栈中没有对应的参数，就溢出到栈底了。

    // va_list ap, 也可以作为参数传递给其他函数，参考vprintf

### 深入理解va\_list
va_list 其实是什么类型呢?好像不是C语言的基本类型,可是也不像是什么结构体.

	typedef char* va_list;

其实根据上面的解释,我们已经可以才出来这一点了.就是va\_list的用法关键在于

- 参数的位置寻址(起始位置和偏移计算)
- 参数的类型(根据约定或者其他信息,然后强制转换)

所以
```
	#define _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1))
	#define va_start(ap, last) (ap = (va_list)&last + _INSIZEOF(last))
    #define va_arg(ap, type) (*(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)))
    #define va_end(ap) (ap = (va_list) 0)
```
上面的`_INTSIZEOF`的宏的目的,主要是要求寻址过程必须按照4字节对齐的限制.在C语言传递参数的时候,char和short都会转变为int整型.占用字节更长的参数,也要是4字节的整数倍,因此是一致的.

`va_arg` macro, moving forward ap pointer, then derefrence its previous address to `type`.

### 其他语言的"可变参数"
现在程序员说自己只会一门语言,出门都不好意思和人打招呼啊.

- 字典形式的可变参数
- 动态类型的列表

对于更"高级"的语言而言,或者支持动态类型(包括列表类型),或者支持按照字典类型来传递参数,这样就几乎彻底解决了"可变参数"的需求.这里面的例子有python,几乎所有的函数式编程语言等等.

## printf
在va\_list的基础上，似乎printf就唾手可得了。

- 创建一个类似的使用可变参数列表的函数
- 一般的字面字符则直接输出
- 以%开始的格式字符串，根据格式解释相应的可变参数的类型，然后转化为字符串。

看上去并不复杂，对吧？
只是上面的第三步实在隐藏了太多太多的细节了。printf支持的参数类型很广泛，
所有的C语言基本类型都支持（而且必须都支持，不然怎么调bug啊）。

    NOTE:
    突然想插入一下，在C语言发明的“上古”时期，C语言自带标准库的特性，还是非常高端的。
    那个时候很多代码还在汇编或者其他上古语言的阶段，自带标准库，使得程序员的程序的基础组件更高阶。
    就像现在python的“自带电池”，以及具有完整的framework的编程语言，都是类似的尽一步发挥。

而且要支持自定义的格式。

    - %%    %字符
    - %c    字符
    - %s    字符串，长度(宽度)支持，左右对齐
    - %d %u %i %o %x %X     整数，short/long类型，左右对齐，长度,精度，符号，进制，补全，进制前缀,前缀的大小写。
    - %f %F %e %E %g %G %a %A       浮点数，同上

这个时候估计看起来就有意思许多啦。:)

关于这个更详细的资料参考：[printf](http://www.cplusplus.com/reference/cstdio/printf/)。
或者直接看man的手册。

细节不说，但还是概要性讲一下。

    %[flags*][width][.precison][length][type]
    flags
    - 0     以0进行补全
    - -     右对齐（没有，则默认左对齐）
    - +     符号输出（大于等于0，输出+，小于0，输出-）
    - <space>   当不需要输出符号（大于等于0）时，输出一个空格
    - #     进制前缀，8进制输出0，16进制输出0x（当type为x的时候，或者0x，当type为X的时候）
    flags 可以进行组合，但不是所有的组合都有效
    width   宽度
    .precision      精度，对于浮点数有效
    length      short 或者long的修饰，例如%lld
    type        类型，如上列

这个上面列的有些我之前也从来没有注意过，比如#和空格的flags。
`%#x`比`0x%x`,语义更清晰，而且要少输一个字符呢。 程序员果然懒惰啊。

	NOTE:
    现在编译器的功能越来越强大,目前已经可以检查出下面的问题
    - fmt字符串和后面参数的个数不匹配
    - fmt字符串类型和后面参数的类型不匹配

以上所有的情况，都要测试通过，还是比较费力的。建议大家可以尝试一下，是一个比较合适的练习题。
以后可以作为面试题啊。

## int -> string
如果仅仅满足与以上，那么这只是一个较为麻烦的状态机而已，用更多的`if`，`else`，之类，总是可以解决的。
在上面都解决的基础上，还有一个问题要考虑，就是数值转换为字符串的问题。

人类可读的字符串，一般要求为10进制，而计算机存储的数据是按照2进制的。
整数情形下，比较简单，直接不断对base求余，然后以整数循环就可以了。

不过这里有个细节要注意，上面的得到对应字符的计算方法，是从低位到高位的。
而我们输出到字符串或者stdout，要从高位到低位的。
这要么通过一个递归算法来完成，要么一个逆序，或者一个缓存空间完成。
我实践中采用的是，先计算出宽度，指针前跳，再回跳计算输出。

## double -> string
那么float和double呢？
简单的看，我们可以利用上面整数的方式一样来。强制转换为整数，然后整数部分按照上面的算法进行。
小数点部分，则通过逐渐乘10,然后得到每一位数。我看到网上也有采用这种方法来实现的,可是这是错误的.

这种方式看上去似乎勉强可行，但是如果这个浮点数过大或者过小显然就无法处理了。

这里有一篇[dragon](http://www.serpentine.com/blog/2011/06/29/here-be-dragons-advances-in-problems-you-didnt-even-know-you-had/)

Steele和White,1990年有一篇论文，提出了[How to print floating-point numbers accurately](http://dl.acm.org/citation.cfm?id=93559)
就是论述如何精确的输出一个浮点数。这个dragon4的算法，在各个标准库中迅速普及.但是dragon4的算法，比较复杂，而且有一定的性能消耗。因为会有些中间结果要计算。

2010年的时候，Florian Loitsch发表了一篇新论文[PLDI](http://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf).
这篇论文的Grisu3算法，速度很快，但是对于0.5%的数值性能不好，需要使用Dargon4算法。这个论文的作者在google,这个算法现在已经应用于V8引擎。并且有一个开源库[double-conversation](https://code.google.com/p/double-conversion/).

Grisu,这个算法名词其实是小龙的意思。哈哈。

    NOTE:
    其实这里才是本文的初衷啊。

## Grisu

我们也可以看到从double到string和从int到string的过程是非常相似的.本质上归结为一个进制转换的问题,都是从2进制转换为10进制.因此理论上是可以使用完全相似的算法.但是double的特点在于,其权重为浮动的.因此数值的范围较为宽广,结合int到string的算法,该算法从低位向高位计算,因此是精确递进的.而double类型,就不再适用了.当数较大的时候,从低位开始的计算是没有意义的.那么上述的算法也就是无从开始.

因此我们需要寻找一个近似,而且可以确定开始位的计算方法.

    TODO

## Deriv
strftime，输出格式化的时间字符串信息。也是采用类似的东西实现的。

%H，就是从相应的时间结构体中找到对应的小时属性，然后打印出来。

实现一个完整的strftime函数。

# ChangList
- 2015-11-15  fix va_list part typo error
