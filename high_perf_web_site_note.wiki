= 高性能网站建设 =
mtime: 2012-11-14 16:45:09 
----
== 序言a ==
页面的性能主要在于前端的数据获取以及脚本解释.因此这部分是性能的关键.
== 序言b ==
HTTP协议,文本协议,在TCP之上.通过\r\n来进行分割.(类似于RTSP).

缓存的方式
# If-Modified-Since:(由浏览器来向服务器确认,数据自此事件是否发生改变)
	服务器返回304,Not Modifyed,表示数据没有发生修改.
# Expires:(服务器第一次发送数据时候就表明其过期事件,从而如果浏览器在此事件范围内,则不会再次发送请求.

Keep-Alive

在一个连接上进行多个请求.(这种方法减少了socket的建立,因为TCP的连接建立时间较长)

socket管道技术

在HTTP1.1中定义,目前尚未被广泛支持.

可以再一个单独的socket中发送多个请求,而无需等待响应.
{{{
	ref:wiki
	HTTP管线化
	将多个HTTP请求整批提交的技术.
	而在传送过程不需要先等待服务器的回应.必须通过永久连接,仅HTTP1.1支持.
	且只有GET,HEAD可以.
}}}
ref:[[http://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96|wiki]]

== 1 减少HTTP请求 ==
=== 图片地图 ===
实际中经常通过图片,来超链接URL.而是要图片地图的方式,则可以将图片的特定位置,关联到一个URL上,从而使得一个图片的不同区域,可以关联不同的目标地址.

这样就使得图片的个数减少.从而减少HTTP请求的次数.加快速度.
`renren的图片浏览中的圈人,至少就采用了这样的技术`

技术实现上,有两种方式.
# 服务器端,图片对应的是同一个URL,但是会带上具体的点击坐标,由服务器据此判断具体的操作.
# 客户端.通过HTML的MAP标签实现.
`个人觉得应该采取第2种方式.`

=== CSS Sprites ===
CSS Sprites方法简而言之就是使用同一张图片，但是提取图片的不同部分，来作为图片显示。但是显然图片地图，要求图片必须是连续的整张图片，但是CSS Sprites的方法则可以更为灵活的使用图片的不同部分，显示不同部分，显然后者更为另外。
`本方法更好`

并且，合并后的图片的体积也会减少，虽然可能合并后的图片会存在空白区域。

=== 内联图片 ===
通过使用data方式，则可以在网页中包含图片，但是却有不会增加额外的HTTP请求。

该方法就是通过data的方式，将图片的二进制数据放在url中，这种方法一般适用于特别小的图片。

该方法的缺点：
# 不受IE低版本支持。
# 存在大小上限，而且数据通过base64编码，实际上会增加传输量（大概30%左右）`但是可以通过压缩再减少大小`
# 因为嵌入在网页中，因此跨页面的时候，图片不会保存。可以讲data放在CSS中，从而实现跨页面使用。但这会引起额外的请求（CSS请求），但是可以得到缓存的好处。

=== 合并js，CSS ===
减少请求数目

可以再编写的时候使用多个js，css文件，而在最后的上线过程，将文件集中在一起。

== 使用CDN ==
CDN

缩短响应时间，缓和web流量峰值压力，缺点是可能受到其他人的流量影响，而且不能完全控制自己的网站（因为部分授权给CDN）。

CDN一般用于发送静态内容。

== ch3 Expires头 ==
如前言所说的。

Expreis的缺点是要求服务器与客户端的时间存在一定的一致性。

而且必须在时间过期后，提供一个新的日期，这个是很枯燥而麻烦的。

=== max-age ===
Cache-Control：max-age=100000

是个解决办法。该方法适用于HTTP1.1

可以同时出现，Expires和max-age，HTTP规范优先考虑max-age.

=== mod_expires ===
Apache模块，可以向max-age一样设置Expires，同时返回Expries头和max-age头。
`最佳解决方案`

但是如何更改链接呢?总不能所有的东西都设置为不变的吧,

可以通过修改文件名,这样就会下载新的文件,从而避免了这个问题.

== 压缩组件 ==
通过Accept-Encoding,来对HTTP的负载内容进行压缩,从而减少网络传输的信息量.

一般而言使用gzip,这是个广泛使用且推荐的压缩方法.

一般对于大于1KB或者2KB的文件,压缩就有意义.

显然压缩到1KB之下,一次TCP传输就可以搞定,这样会快不少.

使用 apache 的 mod_gzip 或者 mod_plate 模块就可以了.(都是使用 gzip 方式压缩,尽管名字不同)

通常,需要为不支持压缩的浏览器特殊处理,从而避免发给其未压缩的内容.

== CSS 放在头部 ==
这样的好处是可以使得网页逐步显示内容,而不是等到最后 CSS下载完毕会才会进行显示.

使用 LINK 标签将 CSS 放到文档的 HEAD 中.

(没有完全明白,回头再说吧)

== 脚本放在底部 ==
脚本会阻塞并行下载过程,因此放在底部.

== 避免 CSS 表达式 ==

== 内联或者外部 CSS 与脚本 ==
放在外部的好处是,很多页面可以重用这些文件.

放在内部的好处是,可以作为一个文件内容下载.

具体看相应的场合.

== 减少 DNS 查找 ==
TTL 一般都很低,不过差距还是蛮大的.

虽然建议为1天,但是很少有使用这么大的值.

使用较少的值,是为了快速的故障转移.因此对于单服务器的环境下,这个值设小了也是无意义的.

通过 Keep-Alive 和使用较少域名,都可以减少 DNS 查找.
== 简化 JavaScript ==
简化,也就是去掉所有的空白和注释.

还可以进一步混淆,也就是自动组合语句,

可以使用工具 JSMin/ShrinkSafe 实现.

前者去掉空白,后者替换变量名

== 避免重定向 ==
301:永久重定向与302暂时重定向是最为常用的.

- 缺少结尾 / 的重定向
	没有 / ,会自动重定向到一个以 / 为结尾的地址.因此避免这个问题.主机名缺少 / 不会引发重定向.
	可以通过 Alias 或者 mod_rewrite 方法解决这个问题.
也可以通过DirecotySlash和直接链接代码避免这一点.

== 移除重复脚本 ==

== 配置 Etag ==
ETag 实体标签

== 使用 Ajax ==


