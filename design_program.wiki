= 程序设计 =
----
“编程是一种一个人告诉另一个人他想让计算机做什么的艺术。” Donald Knuth
== 输入/处理/输出 ==
对于很多程序,它的结构就是如此,需要谨慎的将三者的接口分离.

UNIX的fd的方式是在是太令我赞叹了!

mtime: 2012-11-10 20:16:54
== dummy ==
沟通和设计的时候使用UML还是由必要的,不然很多东西,没有清晰明确的说明.
{{{
	清晰明确是多么的重要!!!
}}}
== 三层架构 ==
三层架构一般是指在程序设计中的架构方式:
# UI	界面层
# BLI	业务逻辑层
# DAL	数据访问层
# DB	数据库
这是很好的实际设计方法,syl,chth,的ott项目就是如此,(不过没有上面那么清晰)
== 封装与性能 ==
显然封装层数越多,性能越差,需要平衡.

程序设计在一定程度上都是平衡的艺术.
==趣味软件开发原则==
ref:[[http://aqee.feedsportal.com/c/34519/f/631690/s/23d8d478/l/0L0Saqee0Bnet0Csolid0Edevelopment0Eprinciples0Ein0Emotivational0Epictures0C/story01.htm|引用网址]]

- 软件开发不是积木游戏
- 单一责任:并不是你能够这样做,你就应该这样做.
- 开发/关闭原则:穿着外套,不要做开胸手术.
- liskov替换原则:如果它看起来像鸭子,声音叫起来像鸭子,但是需要电池,那你可能归纳错了.
- 接口分离原则:你想我把插头插上,插在哪?
- 依赖注入原则:你会把灯泡直接连接到墙里的电线上吗?

==程序员三大美德==
Larry Wall 说过，程序员有三大美德：懒惰、急躁、缺乏耐心。

==时间性能==
[[code_quality|高质量程序设计]]
==delphi的没落==
delphi语言是windows平台下非常好用的界面编程软件.基于pascal,特点是非常快捷方便.

目前已经没落,不建议使用.可以考虑替代的方案如C#,然后使用win From,或者WPF框架.
==防止过度设计==
对于简单的程序,要防止为了设计而设计.

任务本身的功能并不是很复杂,那么就没有必要为了更好的设计而使得程序有着多层结构,有着复杂的接口.

==表现与结构分离==
from:[[zen_of_css_design|CSS禅意花园]]

这个在html网页技术非常明显.

因为其核心就是处理这两个方面的技术.
- 网页提供一个简单的,但是有结构的文档.
- 浏览器为网页进行分析显示.
这样网页必然存在着结构,网页的显示可以非常简单的理解为"表现".

结构通过html代码来输出,(可以通过其他技术生成,例如php,jsp,等等).表现通过css来定义.

发散:

同样的,对于一般的代码,也有这个问题.例如所有的UI设计的程序.

也可以推广到所有的前后台分离的程序.后台负责数据的生成,处理.前台负责显示,交互,配合,接口.

将二者分离,也就是将逻辑与接口分离.

接口是固定不变的,或者提供丰富的接入口,API库调用,rpc远程调用,用户实时输入指令,web远程方式监视.

后台的逻辑是统一的,历经考验的.后台处理着复杂的功能,同步或者异步的方式将自己的结果反馈到前台.
----
==代码长度==
代码应该尽最大可能的简单,短小.

这是重点考虑到人的能力.对机器而言,是没有丝毫的复杂性.它冰冷而无知,仅仅知道按部就班,因此复杂的代码,承受它的只有人而已.

而人的掌控能力是非常有限的.
- 人的视力只能覆盖屏幕,大约40~50行代码就是极限了.
- 人的栈存储空间有限,这个有限是两个层次,
	- 一,存储的内容多少有限,只能够同时记得大概上下文的内容.
	- 二,层数有限,如果理解层数超过3层,基本人只能把它放到纸上辅助理解才可以.
- 人的堆存储空间有限.
	只能够记忆大概几十本书,大概也就是200KB*100=20MB的空间.
- 人的精度有限.
	精度可以说非常之低,很多东西,只有模糊的概念性的东西.
	
因此,代码应该尽可能的简单.

_行数要少,参数要少,调用层次要少._

而不同的编程语言,对代码的复杂度的处理是天然的不一样的.

目前就我个人的使用来看.
- C				比较简单,视不同的框架而定.一般不会特别复杂.
- C++			本身语言较为复杂,理解语言就需要很大的精力.写出的代码,可读性也较差,需要较为扎实的基础才可以.
- Java			类似与C++,某些方面比C++简单,也提供了一些C++不支持的特性.语句的复杂度略高于C++.
- Python		这个是我这个时期最为推崇的.它优雅简单,同时提供了海量的库供调用.非常方便.语句的复杂度也较低.
- lisp之类		这个我一时无法理解如何在实际的工作中去使用它.
- Erlang		提供了很多其他语言,没有提供的特性.很棒.同时复杂度也不是很高.但是库的方面暂时了解不多,应该没有python这么强大.可以考虑在之后服务器代码中使用它.
- processing	同样,很简单,很方便.对于图形的编程非常简单,接口也非常的友好.库不是很丰富(但是本身图形编程也不需要太多).
- ruby			这个应该和python比较类似,但是我不熟悉.
- ...
==健壮设计==
2012-09-21 15:04:12 

从erlang偷师得到的思想,

程序应该划分模块,独立运行(最好是作为独立进程运行).相互之间进行通信.

程序应该有守护进程,守护进程也可以有守护进程.(这个是erlang中的督程概念).

这样就很好的保证了程序的健壮性.
- 程序一部分死掉,其他部分依旧工作正常,而且还可以给出具体的出错模块.
- 程序之间通过通信来进行耦合,避免了相互之间的同步问题.便于并行和加速.
- 工作任务有督程的存在,可以保证快速的重启任务,这样在出错之后,可以快速的进行恢复.
- 强行的进行模块划分,提高了模块的重用性.

但是,对于一般的C++程序,这些都比较麻烦,仅仅是提供一个督程的框架,应该开发起来就很复杂.

进程间的信号传递也是个麻烦的问题.下面的实现,具体使用什么方式呢,我喜欢的是socket,又怕影响速度.

如果直接采用erlang进行开发,或者进行混合编程应该可以解决这个问题.

例如:BeeSys这个系统 [[BeeSys_2Bee_design]].
- 日志系统可以作为独立进程,这样会大大提高了复用性.
- 分离主任务为,监视文件夹变动,与文件传输两个进程,两个进程可以进行通信.

==基于流的编程==
基于流的编程也是类似的思想.(类似与 *健壮设计* 中的思想)

就是划分模块,信息传递.

FBP书的第一版出版为1994年,可见,这个很多都不是新鲜的想法.
[[http://en.wikipedia.org/wiki/Flow-based_programming|Flow-base programming]]
