= shell script programming =

== bash basic ==

=== logic about file ===
* -d    dir exist?
* -z    var exist?
* -f    file exist?
* -L    link exist?
* -r    read?
* -w    write?
* -x    executable?
* !     negtive
* -nt   compare access time with two files

=== logic about string ===
* =     equal?
* ==    equal?
* !=    not equal?
* -n    is null? or is not init?

string with wildcard, using start symbol.

$abc == *abc*

=== logic about number ===
* -eq   equal?
* -gt   greater than
* -lt   less than

== assign ==
directly assign
V=val

=== read ===
read -p "prompt message" val
== array ==
* define
arr[0]=1
arr[1]=2

bash::
arr=(1 2)
arr=(1, 2)

* access
${array_name[index]}

access all items
${array_name[@]}
${array_name[*]}

* loop on array
for a in ${array[@]}
do
    ...
done

* loop on array with index
{{{
for (( i = 0 ; i < ${#names[@]} ; i++ )) do
    echo ${names[$i]}
done
}}}

=== more bash options ===
* -v                verbose
* -u/-o nounset     unset var, will quit
* -e/-o errexit     exit when any command return false
but now you can judge on $?, will have to use && or || to combine command
* -o pipefall       fail when one of pipe fall (default as last command)
reverse operation +v or +u ...

example::
:script:
set -v on

:cmd:
bash -v

=== trap ===
trap for clean state, when script have some exceptional condition.

trap command signal [signal ...]

* INT   Interrupt, Ctrl-C
* TERM  Terminate, kill
* EXIT  exit, when script exit, send this signal

XXX:
trap will continue run command which after it.
so remember add a "exit" in trap command.
this is like case: break in C.
== getops ==
参数解析

== judge and branch ==

=== case ===
{{{
    case $val in
        [0]* ) ...break;;
        [1]* ) ...break;;
        * ) ...;;
    esca
}}}
== loop ==
=== for ===
=== while ===
=== until ===
{{{
    until command ; do
        do sth...
    done
}}}
== fucntion ==
=== grammer ===
sh

FuncName(){
    body
}

bash

function FuncName(){
    body
}
and compatable with sh style, but XXX: sh not compatable with bash style

=== return value ===
# return expression
only return number, like other programing language.

using $?, to access last command exit value

0, ok, success.
other value, some error happend

{{{
if mytest args; then
    dosth
fi
}}}
good to use as conditional

# change global or environment Var to return value

but last 2 method won't work when run in subprocess,
as not return value for subprocess,
and child-process cannot modify parent-process env-var

# using stdout to return val,
`ret=$(func param1 prarm2)`

not output anything, will mix stdout

# using eval functional style return
{{{
    function pass_back_a_string() {
        eval "$1='a test str'"
    }
    pass_back_a_string return_var
    echo $return=var
}}}

this's fantastic. even return_var is local var, this style could pass return
value to it.
== string operation ==
=== judge or get string var value ===
* ${var}            var value, same with var
* ${var-DEFAULT}    if var not exist, return default.
* ${var:-DEFAULT}   if var not exist or is blank string, return default.
* ${var=DEFAULT}    if var not exist, setting its value to DEFAULT
* ${var:=DEFAULT}   if var not exist or is blank string, setting its value to
DEFAULT
* ${var+OTHER}      if var exist, then return OTHER, else return blank string.
* ${var:+OTHER}     if var setting, ...
* ${var?ERR_MSG}    if var not exist, then print ERR_MSG
* ${var:?ERR_MSG}   if var not setting, ...
* ${!varprefix*}    match all var which startswith varprefix (only return var
name)
* ${!varprefix@}    lbid

=== string operation ===
* ${#string}        length of str
* ${str:pos}        substr from pos
* ${str:pos:len}    substr from pos and length is len
* ${str#sub}        from head, delete shortest matched substr
* ${str##sub}       from head, delete longest matched substr
* ${str%sub}        from tail, delete shortest matched substr
* ${str%%sub}       from tail, delete longest matched substr
* ${str/sub/rep}    replace first sub to rep
* ${str//sub/rep}   replace all sub to rep
* ${str/#sub/rep}   if str has sub as its prefix, then replace rep to sub
* ${str/%sub/rep}   if str has sub as its suffix, then replace rep to sub

all sub could be a Regular Expression.

`${var##*/}`        var is path, delete all dirname, get basename
`${var%/*}`       var is path, delete basename, get dirname

== meta skill ==
=== dynamic var name ===
{{{
b=a
a=1
echo ${!b}
}}}
this will display 1, this mean metaprogramming, code generation.

=== command string ===
run a command stored in string.

`eval "$command"`

= shell comparation =

* zsh and bash handle `complete` different. zsh could not support this directly.

* zsh handle for space delemiter string is error.

* zsh will initiative expand asterisk symbol self first, so when faild, maybe whole command will stop.

`ls /usr/*/pythonabc* /usr/*/lib/python* 2>/dev/null`

using `noglob`, will prevent zsh to expand asterisk, for example: `noglob echo 2*3 | bc`

but `ls` still fail

----
default ubuntu and debian, sh is DASH

== export source ==
export to make it work in child-shell

source to make it work in parent-shell

and DOT is only for sh, and bash compatable with sh

export -f FuncName
export Varname

XXX: can not export array Var
== gotchas ==

* assign reserved words or chars to var name.
* using a hyphen or other reserved char name.
only use _ in var or function name.
* using same name for a var and a function.
* using whitespace inappropriately.
In bash, you have to using whitespace exactly.
for var init, not using whitespace, other issue, add whitespace.
* add semicolon ; for the final command in code block.
or bash can not detect EOF.
* uninit var will get blank string default.
using set -u or set -o nounset to defend this BUG.
* = -eq, different meaning
= is for string compare, while -eq for number.
* string compare
> < for redirect stdin or stdout, \< \> is for string compare.
-gt -lt is for number.
* using let for var assign
let is only for number arithmetic operations on var.
* var with [], need to be quoted with ""
* quoting a var containg whitespace prevents auto spliting.
* commands will faild to execute when script runner lacks permissions.
* DONOT using - as a redirection operator.
* exit staus of an arithmetic not equivalent to an errorcode.
* using DOS-stype \r\n will fail to execute
dos2unix to transfer it.
* not push whitespace in front of termiating limit string of a here document.
here document will introduce when next time use it.
* puting more ouput when using echo result as return value.
* not trying using var in a subshell
* piping echo output to a read may produce unexpcted results.
may not quit.
example:
tail -f somefile | grep abc
* not using SUID command, this is dangrous.
* using shell script for CGI maybe problems, as shell var are not typesafe.
shell script is so easy to crack.
SHELLSHOCK.
* bash does not handle double slash // string correctly.

using shellcheck to detect this warnings to write robust bash script.

* add local,readonly decorator
