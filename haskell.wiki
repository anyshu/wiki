= haskell =
== basic ==
- infix expression
`1 + 2`
- prefix expression
`(+) 2 2`

== type ==
*strong static* type system and can be automatically *inferred*

*abstraction*

A programming lanuage's type system deeply colours the way we think, and write
code, in that languages.

NOTE:
so right!
python is duck-type, not check the type, but check the interface or property.
but haskell, is use inferred type system. and *typeclasses*

type inferring system/static type system, make debuging on type error
*up front*. (than dynamic type system)

`'a' :: Char`
type signnature

`:type ???`
return type of classes

=== basic ===
==== number ====
- Int           INT32 or INT64
- Integer       unlimited Integer
- IntegerS
- IntS
- Double
rational number
`11%29` -> 11/29

predication function::
- odd
- even
- compare
    - LT, GT, EQ


- Char
- Bool
- List          [1, 2, 3]
- string        "abc"
    * string is list of char/int
    * "" == []
=== list ===
enumeration notation

*polymorphic*

elements of list must have same type

`[1..10]`
`[1.0,1.25..2.0]`
`[1.0..1.8]` -> [1.0, 2.0]

==== implemention ====
the list is like functional programming language, FP, support `cons`, `car`, `cdr`
is better.

==== operator on list ====
- ++            extend/concatenate
- :             cons        `1 : [2, 3]` -> [1, 2, 3]
- head
- tail
    - tail []
    *** Exception: Prelude.tail: empty list
- !!            index operation, `lst !! 3`
- last
- take n list
- drop n list

==== list comprehension ====
`[x * 2 | x <- [1..10], x > 5]`

list generate, and predicate function have multi-number, just split by comma

`[x * y | x <- [1..10], y <- [1..10], x /= 2, odd y]`

also support embed in list comprehension

=== tuple ===
`()` work [[as]] *void* in C.

=== pair ===
- fst
- snd
only support pair or tuple which containing TWO elements.
== math ==
=== operator ===
- +
- -
- /
- **
- ^
- rem
- mod       not same, mod have defintion on negative number
- precedence of operators
`1 + 4 * 4` -> 17
- () bracket
=== logic ===
- True
- False
- Not zero value, is not True, not False
- &&
- ||
- not
- ==
- /=        not equal(not "!=" as C style)
- <
- >
- >=
- <=

=== constanst ===
- pi
=== function ===
- exp
- sqrt
- succ      successor
- pred      predosser???
- truncate  truncate number to intger
- round
- floor
- ceiling
- sin

== function ==
based on function type definition in Haskell, we can see it support "curry" of
function.

*curry*

given part of parameters of function to build new function.
or combinition one param function to construct multi-param function.

=== function type ===
{{{
    :type elem
    elem :: Eq a => a -> [a] -> Bool
}}}
*->*
right-combined

=== char in function name ===
we could use ' in function name, as use it as "modification" version of
orignal function.

=== midfix function ===
{{{
div 92 10
92 `div` 10
}}}

we even could define a function as midfix format.
== typeclass ==
- Eq        /= ==
- Ord       > < >= <=       GT LT EQ
- Show
- Read
- Enum
- Bounded
- Num
- Integral
- Floating

NOTE:
Read, Show is *reverse* typeclass.
== pattern matching ==
- all@(x:xs)        @ -> as

patter matching could apply in function param parse, *where* statement, *let*
statement.

=== guard ===
{{{
func param
    | param <= val = "abc"
    | param < val1 = "def"
    | otherwise = "other"
}}}
== where vs. let in ==
~~we could define helper function in *where* statement.~~

`let [bindings] in [expressions]`

*where* is syntax struct, but *let* is expression.

bindings in let, could split by ";".

=== lambda function ===
just starts with "\" as *lambda*

=== high order function ===
==== fold ====
foldr, foldl, start with the right or left side of list.

use *foldr* is better than *foldl* when apply on List, as left *cons*/*:* is
faster than *append*/*++* on List.

and *foldr* could apply on unlimited List, but *foldl* NOT.

foldl1, foldr1, without initial value, but must have one value in List.

==== scan ====
just different than *fold*, is store accumlate state to list.

==== dollar ====
`map ($ 3) [(4 +), (10 *)]`

==== function composition ====
{{{
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
}}}

== module ==
{{{
import
:m
:module
import as
import qualified Data.Map as M
}}}

== exception ==
* error         throw a ERROR (and literal string as param)
== IO ==
=== output ===
- putStrLn

== syntax ==
- comment       begin with "--"

= ghc =
- ghc [filename]    compile
== ghci ==
- ghci              interative intreprator
- :?                get help
- :type
- :load
    * :load filename
    * :load filename.hs
    * :load "filename.hs"
- :cd

Inside ghci, define a new variable, need using *let*

= NOTE =
unlike other language, function only means definition a map or a functor,
       which from value of one type to value of other type.

but in Haskell, we can definition a functor, which from one type to other
type.

and we can infered function, and calculate and combine functiont to build new
/high level functor.

== Maybe ==
in Haskell, Maybe is better than C's return value style, and better than
Python's _NONE_ style.

In Erlang, we have same style.

but in Haksell, this support infered tyle system. GOOD.
= issues =
== align ==
haskell use *align* to parse the program.
= Book =
Learn your haskell for great good, is better for newbie than real world
haskell.
