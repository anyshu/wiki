= haskell =
== basic ==
- infix expression
`1 + 2`
- prefix expression
`(+) 2 2`

== type ==
*strong static* type system and can be automatically *inferred*

*abstraction*

A programming lanuage's type system deeply colours the way we think, and write
code, in that languages.

NOTE:
so right!
python is duck-type, not check the type, but check the interface or property.
but haskell, is use inferred type system. and *typeclasses*

`'a' :: Char`
type signnature

=== basic ===
==== number ====
- Integer
- IntegerS
- IntS
- Double
rational number
`11%29` -> 11/29

predication function::
- odd
- even
- compare


- Char
- Bool
- list          [1, 2, 3]
- string        "abc"
    * string is list of char/int
    * "" == []
=== list ===
enumeration notation

`[1..10]`
`[1.0,1.25..2.0]`
`[1.0..1.8]` -> [1.0, 2.0]

==== operator on list ====
- ++            extend/concatenate
- :             cons        `1 : [2, 3]` -> [1, 2, 3]

== math ==
=== operator ===
- +
- -
- /
- **
- ^
- precedence of operators
`1 + 4 * 4` -> 17
- () bracket
=== logic ===
- True
- False
- Not zero value, is not True, not False
- &&
- ||
- not
- ==
- <
- >
- >=
- <=

=== constanst ===
- pi
=== function ===
- exp
- sqrt
- succ      successor
- pred      predosser???
- truncate  truncate number to intger
- round
- floor
- ceiling
- sin

== IO ==
=== output ===
- putStrLn

== syntax ==
- comment       begin with "--"

= ghc =
- ghc [filename]    compile
== ghci ==
- ghci              interative intreprator
- :?                get help
