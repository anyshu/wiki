= haskell =
== basic ==
- infix expression
`1 + 2`
- prefix expression
`(+) 2 2`

== type ==
*strong static* type system and can be automatically *inferred*

*abstraction*

A programming lanuage's type system deeply colours the way we think, and write
code, in that languages.

NOTE:
so right!
python is duck-type, not check the type, but check the interface or property.
but haskell, is use inferred type system. and *typeclasses*

type inferring system/static type system, make debuging on type error
*up front*. (than dynamic type system)

`'a' :: Char`
type signnature

`:type ???`
return type of classes

=== basic ===
==== number ====
- Int           INT32 or INT64
- Integer       unlimited Integer
- IntegerS
- IntS
- Double
rational number
`11%29` -> 11/29

predication function::
- odd
- even
- compare
    - LT, GT, EQ


- Char
- Bool
- List          [1, 2, 3]
- string        "abc"
    * string is list of char/int
    * "" == []
=== list ===
enumeration notation

*polymorphic*

elements of list must have same type

`[1..10]`
`[1.0,1.25..2.0]`
`[1.0..1.8]` -> [1.0, 2.0]

==== implemention ====
the list is like functional programming language, FP, support `cons`, `car`, `cdr`
is better.

==== operator on list ====
- ++            extend/concatenate
- :             cons        `1 : [2, 3]` -> [1, 2, 3]
- head
- tail
    - tail []
    *** Exception: Prelude.tail: empty list
- !!            index operation, `lst !! 3`
- last
- take n list
- drop n list

==== list comprehension ====
`[x * 2 | x <- [1..10], x > 5]`

list generate, and predicate function have multi-number, just split by comma

`[x * y | x <- [1..10], y <- [1..10], x /= 2, odd y]`

also support embed in list comprehension

=== tuple ===
`()` work as *void* in C.

=== pair ===
- fst
- snd
only support pair or tuple which containing TWO elements.
=== Algebraic Data Types ===
==== Value Consturctor ====

`data TYPECONS = VALUECONS TYPE0 TYPE1 | VALUECONS TYPE10 deriving (Show)`

Value Consturctor is a function.

==== Type Constructor ====
`data Maybe a = Nothing | Just a`

=== Record Syntax ===
{{{
data Person = Person { firstname :: String, lastname :: String }
}}}
== functor ==
we have a complex? or a different kind? type, we can define a functor on the
TYPE, then map to different operation on different kind? type.
== kind ==
type of type -> kind.

{{{
:kind Maybe
Maybe :: * -> *
}}}
this means, Maybe's type is a map, which construct a type to another type.
== math ==
=== Integer & Int ===
Integer::
bitnum

Int::
fix length 64 bit INT

`toIntger` will convert Int to Integer.

Must first convert when it in right scope. convert one Int which already
overflow is meaningless.

=== operator ===
- +
- -
- /
- **
- ^
- rem
- mod       not same, mod have defintion on negative number
- precedence of operators
`1 + 4 * 4` -> 17
- () bracket
=== logic ===
- True
- False
- Not zero value, is not True, not False
- &&
- ||
- not       (not "!" as C style)
- ==
- /=        not equal(not "!=" as C style)
- <
- >
- >=
- <=

=== constanst ===
- pi
=== function ===
- exp
- sqrt
- succ      successor
- pred      predosser???
- truncate  truncate number to intger
- round
- floor
- ceiling
- sin
- log       base 10
- logBase

== function ==
based on function type definition in Haskell, we can see it support "curry" of
function.

*curry*

given part of parameters of function to build new function.
or combinition one param function to construct multi-param function.

=== function type ===
{{{
    :type elem
    elem :: Eq a => a -> [a] -> Bool
}}}
*->*
right-combined

=== char in function name ===
we could use ' in function name, as use it as "modification" version of
orignal function.

=== midfix function ===
{{{
div 92 10
92 `div` 10
}}}

we even could define a function as midfix format.
== typeclass ==
- Eq        /= ==
- Ord       > < >= <=       GT LT EQ
- Show
- Read
- Enum
- Bounded
- Num
- Integral
- Floating

NOTE:
Read, Show is *reverse* typeclass.
== pattern matching ==
- all@(x:xs)        @ -> as

patter matching could apply in function param parse, *where* statement, *let*
statement.

=== guard ===
{{{
func param
    | param <= val = "abc"
    | param < val1 = "def"
    | otherwise = "other"
}}}
== where vs. let in ==
~~we could define helper function in *where* statement.~~

`let [bindings] in [expressions]`

*where* is syntax struct, but *let* is expression.

bindings in let, could split by ";".

=== lambda function ===
just starts with "\" as *lambda*

`(\x -> fn x)`

=== high order function ===
==== fold ====
foldr, foldl, start with the right or left side of list.

use *foldr* is better than *foldl* when apply on List, as left *cons*/*:* is
faster than *append*/*++* on List.

and *foldr* could apply on unlimited List, but *foldl* NOT.

foldl1, foldr1, without initial value, but must have one value in List.

==== scan ====
just different than *fold*, is store accumlate state to list.

==== dollar ====
`map ($ 3) [(4 +), (10 *)]`

==== function composition ====
{{{
(.) :: (b -> c) -> (a -> b) -> a -> c
f . g = \x -> f (g x)
}}}

== module ==
{{{
import
:m
:module
import as
import qualified Data.Map as M
}}}

`Type(..)` to export self defined TYPE function.(But we still could use that
type)

module filename must same with module name

=== define a module ===
{{{
module MDLNAME
(EXPORT_FUNC_NAME0
,EXPORT_FUNC_NAME1
) where

-- define func
}}}
== exception ==
* error         throw a ERROR (and literal string as param)
== IO ==
=== output ===
- putStrLn
=== return ===
in haskell, return only one expression, which one return a IO action, but not
return the function.

when we must get an IO action, but not need really do sth, we should use
`return ()`

but the programming will continue to execute after this expression.
== syntax ==
- line comment       begin with "--"
- block comment     `{- comment here -}`

== Monad ==
`Monad` is a `class`, which have two basic operators:

{{{ haskell
infix 1 >>, >>=
class Monad m where
    -- >>= and >> is bind operator
    (>>=)   :: m a -> (a -> m b) -> m b
    return  :: a -> m a
    -- other not BASIC
    (>>)    :: m a -> m b -> m b
    fail    :: String -> m a
    m >> k = m >>= \_ -> k
}}}

For example: `list` is a monad.
so
{{{
(>>=) :: [a] -> (a -> [b]) -> [b]
}}}
= ghc =
- ghc [filename]    compile
- -o [executable filename]
This need `main` function at `main` module.
== ghci ==
- ghci              interative intreprator
- :?                get help
- :type
- :info
- :module
- :load
    * :load filename
    * :load filename.hs
    * :load "filename.hs"
- :cd
- it
default return value, `ans` in matlab

Inside ghci, define a new variable, need using *let*

== runghc ==
directly execute the haskell as script

not generate .o or executable file, not enter to ghci
= NOTE =
unlike other language, function only means definition a map or a functor,
       which from value of one type to value of other type.

but in Haskell, we can definition a functor, which from one type to other
type.

and we can infered function, and calculate and combine functiont to build new
/high level functor.

== Maybe ==
in Haskell, Maybe is better than C's return value style, and better than
Python's _NONE_ style.

In Erlang, we have same style.

but in Haksell, this support infered tyle system. GOOD.
= issues =
== align ==
haskell use *align* to parse the program.
= Book =
Learn your haskell for great good, is better for newbie than real world
haskell.
